## 1 总览

算法总览



### 1.1 数据结构分类

* 一维
  * 基础：数组 array（string）、链表 linked list
  * 高级：栈 stack、队列 queue、双端队列 deque、集合 set、映射 map（hash or map）
* 二维
  * 基础：树 tree、图 graph
  * 高级：二叉搜索树 binary search tree（red - black tree）、堆 heap、并查集 disjoint set、字典树 trie
* 三维
  * 位运算 Bitwise、布隆过滤器 BloomFilter
  * LRU Cache

### 1.2 算法

算法最终基于下面三个基本单元、也就是基石：

* if - else、switch -> branch
* for、while loop -> Iteration
* 递归 Recursion（Divide & Conquer、Backtrace）

基于上面的三个基本单元，衍生高级的算法，其实都有一套模板变来变去：

* 搜索 Search：深度优先搜索（DFS） Depth first search、广度优先搜索 Breadth first search（BFS）
* 动态规划（DP） Dynamic Programming
* 二分查找 Binary Search
* 贪心 Greedy
* 数学 Math、几何 Geometry

### 1.3 如何练习

* 拆分知识点

* 刻意练习 - 过遍数（五毒神掌）、练习缺陷、弱点地方
* 即时反馈（主动、被动）

### 1.4 切题四件套

* 仔细看题目、明白多看几遍、明白题目的意思
* 想所有可能的解法 -> 找最优
* 写代码
* 测试

### 1.5 五毒神掌

#### 第一遍

* 5分钟：读题 + 思考
* 如果没有思路，直接看解法，比较优劣
* 背诵、默写好的解法

#### 第二遍

* 写代码测试 -> 最优

#### 第三遍

* 过一天，重复做题

#### 第四遍

* 过一周，重复做题

#### 第五遍

* 过一个星期，恢复性训练

## 2 复杂度分析

常见的时间复杂度：

* O(1) — 常数复杂度

* O(log n) — 对数复杂度

* O(n) — 线性复杂度

* O(n log n) — 对数线性复杂度
* O(nᵏ) — 多项式复杂度
* O(kⁿ) — 指数复杂度
* O(n!) — 阶乘复杂度

## 3 数组、链表、跳表

### ArrayList

增删慢，时间复杂度 O(n)

查询快，时间复杂度 O(1)

### LinkedList -> LRU Cache

增删快，时间复杂度 O(1)

查询慢，时间复杂度 O(n)

### 跳表 Skip List -> Redis 中使用

为了补足链表的缺陷而设计出来。

解决方法：**升维、空间换时间**

链表：增加索引，时间复杂度 O(log n)、空间复杂度 O(n)















